local dump = require 'luadump'
local inspect = require('inspect')
local vec3 = require 'vec3'
local transf = require 'transf'

function data()
    --local test = require('lollo_medium_1_way_1_lane_street.lua')
    local function _fileExists(fileName)
        local file = io.open(fileName, 'r')
        if file then
            file:close()
            return true
        end
        return false
    end
    local function _readFile(fileName)
        local file = io.open(fileName, 'r')
        if file then
            print('LOLLO file found') -- it gets here
            print(inspect(file)) -- file has type userdata
            dump(true)(file)
            print('LOLLO start reading the file')
            local fileContents = file:read('*a') -- this works! it reads the file contents! However, it adds a funny character at the beginning
            -- local fileContents = file:read() -- let's s ee about that funny character - nope, and it only reads the first line
            -- print(inspect(fileContents))

            --fileContents = 'return ' .. string.sub(fileContents, 4) -- -- get rid of the funny character at the beginning and add return
            --fileContents = 'return ' .. string.sub(fileContents, 25) -- -- get rid of the funny character at the beginning and the named function
            fileContents = string.sub(fileContents, 24) -- -- get rid of the funny character at the beginning and the named function
            fileContents = string.sub(fileContents, 1, string.len(fileContents) - 4) -- get rid of end at the end
            print('LOLLO adjusted file contents = ')
            dump(true)(fileContents)

            print('LOLLO closing the file')
            file:close()

            --local myFileFunc = loadstring(fileContents) -- it fails coz loadstring is not available
            local func, err = load('return function(a,b) return a+b end')
            if func then
                local ok, add = pcall(func)
                if ok then
                    print('LOLLO test 4 load', add(2, 3))
                else
                    print('Execution error:', add)
                end
            else
                print('Compilation error:', err)
            end

            local func, err = load(fileContents)
            if func then
                local ok, fc = pcall(func)
                if ok then
                    print('LOLLO test 4 load -----------------------------------')
                    dump(true)(fc) -- fc now contains my street data!
                else
                    print('Execution error:', fc)
                end
            else
                print('Compilation error:', err)
            end

            return true
        else
            print('LOLLO file not found')
        end
        return false
    end

    local function _readFile2(fileName)
        local file = io.open(fileName, 'r')
        if file then
            print('LOLLO file found') -- it gets here
            print(inspect(file)) -- file has type userdata
            dump(true)(file)
            print('LOLLO start reading the file')

            local fileContents = file:read('*a') -- this works! it reads the file contents! However, it adds a funny character at the beginning
            -- local fileContents = file:read() -- let's s ee about that funny character - nope, and it only reads the first line
            -- print(inspect(fileContents))

            --fileContents = 'return ' .. string.sub(fileContents, 4) -- -- get rid of the funny character at the beginning and add return
            --fileContents = 'return ' .. string.sub(fileContents, 25) -- -- get rid of the funny character at the beginning and the named function
            fileContents = string.sub(fileContents, 4) -- -- get rid of the funny character at the beginning
            fileContents = string.gsub(fileContents, 'function data%(%)', '', 1) -- % escapes in lua...
            fileContents = string.gsub(fileContents, 'end', '', 1)
            print('LOLLO adjusted file contents = ')
            dump(true)(fileContents)

            print('LOLLO closing the file')
            file:close()

            --local myFileFunc = loadstring(fileContents) -- it fails coz loadstring is not available
            local func, err = load('return function(a,b) return a+b end')
            if func then
                local ok, add = pcall(func)
                if ok then
                    print('LOLLO test 4 load', add(2, 3))
                else
                    print('Execution error:', add)
                end
            else
                print('Compilation error:', err)
            end

            local func, err = load(fileContents)
            if func then
                print('LOLLO func = ##################')
                print(inspect(func))
                dump(true)(func)
                local ok, fc = pcall(func)
                if ok then
                    print('LOLLO test 4 load -----------------------------------')
                    dump(true)(fc) -- fc now contains my street data!
                    print(inspect(fc))
                else
                    print('Execution error:', fc)
                end
            else
                print('Compilation error:', err)
            end

            return true
        else
            print('LOLLO file not found')
        end
        return false
    end

    local function _readFile3(fileName)
        local result = nil
        local file = io.open(fileName, 'r')
        if file == nil then
            print('LOLLO file not found')
            return false
        end

        print('LOLLO file found') -- it gets here
        print(inspect(file)) -- file has type userdata
        dump(true)(file)
        print('LOLLO start reading the file')

        local fileContents = file:read('*a') -- this works! it reads the file contents! However, it adds a funny character at the beginning
        -- local fileContents = file:read() -- let's s ee about that funny character - nope, and it only reads the first line
        -- print(inspect(fileContents))

        --fileContents = 'return ' .. string.sub(fileContents, 4) -- -- get rid of the funny character at the beginning and add return
        --fileContents = 'return ' .. string.sub(fileContents, 25) -- -- get rid of the funny character at the beginning and the named function
        fileContents = 'return ' .. string.sub(fileContents, 4) -- -- get rid of the funny character at the beginning and prepend return instead
        -- remove the function name (which is always "data"). Consider the following:
        --[[             
            local ee = return function(a,b) return a+b end -- works
            local ee = return function data(a,b) return a+b end -- fails
 ]]
        -- make several attempts just in case the file is badly formatted
        local howManyMatches = 0
        fileContents, howManyMatches = string.gsub(fileContents, ' data%(%)', '()', 1) -- % escapes in lua...
        if howManyMatches == 0 then
            fileContents, howManyMatches = string.gsub(fileContents, ' data %(%)', '()', 1) -- % escapes in lua, however, it must not go into the replacement string
        end
        if howManyMatches == 0 then
            fileContents, howManyMatches = string.gsub(fileContents, ' data  %(%)', '()', 1) -- % escapes in lua...
        end

        -- leave if howManyMatches is still 0
        if howManyMatches == 0 then
            return false
        end

        print('LOLLO adjusted file contents = ')
        dump(true)(fileContents)

        print('LOLLO closing the file')
        file:close()

        --local myFileFunc = loadstring(fileContents) -- it fails coz loadstring is not available
        local func, err = load('return function(a,b) return a+b end')
        if func then
            local ok, add = pcall(func)
            if ok then
                print('LOLLO test 4 load', add(2, 3))
            else
                print('Execution error:', add)
            end
        else
            print('Compilation error:', err)
        end

        local func, err = load(fileContents)
        if func then
            print('LOLLO func = ##################')
            print(inspect(func))
            dump(true)(func)
            local ok, fc = pcall(func)
            if ok then
                --print(inspect(fc))
                print('LOLLO test 4 load -----------------------------------')
                dump(true)(fc()) -- fc now contains my street data!
                result = fc()
            else
                print('Execution error:', fc)
            end
        else
            print('Compilation error:', err)
        end

        return true, result
    end
    local function readFiles(files)
        local info
        local i = 1
        repeat
            info = debug.getinfo(i, 'S')
            i = i + 1
            print('LOLLO info = ')
            require('luadump')(true)(info)
        until info == nil
        info = debug.getinfo(i - 2, 'S')
        local file, err = loadfile('C:/Program Files (x86)/Steam/userdata/71590188/1066780/local/staging_area/lollo_street_tuning_1/res/config/street/lollo_medium_1_way_1_lane_street.lua')
        print('LOLLO err = ', err)
        print(inspect(file)) -- a function
        print(inspect(file())) -- nil. Note that street files do not return anything.

        -- this works!
        --_readFile('C:/Program Files (x86)/Steam/userdata/71590188/1066780/local/staging_area/lollo_street_tuning_1/res/config/street/lollo_medium_1_way_1_lane_street.lua')
        -- this works, too
        -- _readFile2('C:/Program Files (x86)/Steam/userdata/71590188/1066780/local/staging_area/lollo_street_tuning_1/res/config/street/lollo_medium_1_way_1_lane_street.lua')
        -- this works, too
        print('############################ _readFile3 returned with')
        dump(true)(_readFile3('C:/Program Files (x86)/Steam/userdata/71590188/1066780/local/staging_area/lollo_street_tuning_1/res/config/street/lollo_medium_1_way_1_lane_street.lua'))
        --require('luadump')(true)(file.data()) -- NO! file is a function!
        --require('luadump')(true)(file().data())
        print('LOLLO package.path = ')
        dump(true)(package.path)
        -- this works
        package.path = package.path .. ';C:/Program Files (x86)/Steam/userdata/71590188/1066780/local/staging_area/lollo_street_tuning_1/res/config/street/lollo_medium_4_lane_street.lua'
        -- this fails
        package.path = package.path .. ';C:/Program Files (x86)/Steam/userdata/71590188/1066780/local/staging_area/lollo_street_tuning_1/res/config/street/?.lua'
        dump(true)(package.path)
        --print('LOLLO package.loaded = ')
        --dump(true)(package.loaded) huge
        print('LOLLO package.loaders = ')
        dump(true)(package.loaders)
        --print('LOLLO package.preload =')
        --dump(true)(package.preload)
        -- table.insert(package.preload, #package.preload + 1, 'C:/Program Files (x86)/Steam/userdata/71590188/1066780/local/staging_area/lollo_street_tuning_1/res/config/street/?.lua')
        -- table.insert(package.preload, #package.preload + 1, 'C:/Program Files (x86)/Steam/userdata/71590188/1066780/local/staging_area/lollo_street_tuning_1/res/config/street/lollo_medium_4_lane_street.lua')
        -- table.insert(
        --     package.preload,
        --     #package.preload + 1,
        --     {
        --         ['lollo_medium_4_lane_street.lua'] = 'C:/Program Files (x86)/Steam/userdata/71590188/1066780/local/staging_area/lollo_street_tuning_1/res/config/street/lollo_medium_4_lane_street.lua'
        --     }
        -- )
        --package.preload['lollo_medium_4_lane_street.lua'] = 'C:/Program Files (x86)/Steam/userdata/71590188/1066780/local/staging_area/lollo_street_tuning_1/res/config/street/lollo_medium_4_lane_street.lua'
        --dump(true)(package.preload)
        local qqq = require('lollo_medium_4_lane_street')
        dump(true)(qqq) -- qqq is a boolean (true in this case).
        -- Yes the require works, but the required file does not return anything,
        -- because this is how street files are designed. So I need to read the file and parse it somehow.
        --dump(true)(qqq.data)
        -- dump(true)(qqq.data())

        -- local modPath
        -- if string.ends(info.source, 'mod.lua') then
        --     modPath = string.gsub(info.source, "@(.*/)mod[.]lua", "%1")
        -- elseif string.ends(info.source, '.mdl') then
        --     modPath = string.gsub(info.source, "@(.*/)res/models/model/.+[.]mdl", "%1")
        -- elseif string.ends(info.source, '.lua') then
        --     modPath = string.gsub(info.source, "@(.*/)res/config/street/.+[.]lua", "%1")
        -- end

        -- print('LOLLO modPath = ', modPath)

        -- if _fileExists(modPath.."mod.lua") then
        --     print('LOLLO file found')
        -- else
        --     print("LOLLO file found [ModUtil] Could not read files. Maybe the function was called from a wrong file.")
        -- end
    end
    readFiles({})

    return {
        type = 'STREET_CONSTRUCTION',
        description = {
            name = _('Parallel streets'),
            description = _('Lays two parallel streets.')
        },
        availability = {
            yearFrom = 0,
            yearTo = 0
        },
        -- params = { -- LOLLO here, you can add some parameters, such as the street type
        --     {
        --         key = "streetType2",
        --         name = _("Number of lanes"),
        --         values = { _("2"), _("3") },
        --         defaultIndex = 0,
        --         yearFrom = 1960,
        --         yearTo = 0
        --     },
        --     {
        --         key = "scale",
        --         name = _("Scale"),
        --         values = { _("Small"), _("Medium"), _("Large") },
        --         defaultIndex = 0,
        --         yearFrom = 1960,
        --         yearTo = 0
        --     },
        -- },

        order = 1,
        -- collider = {
        --     type = 'NONE'
        -- },
        -- autoRemovable = true,
        --skipCollision = true,
        --skipCollisionCheck = true,
        updateFn = function(params)
            print('LOLLO parallel streets updateFn')
            -- dump(true)(params)

            local result = {}
            --result.colliders = {}
            result.cost = 0
            --result.edgeLists = {}
            result.models = {}
            result.groundFaces = {}
            --		result.h0 = {}
            --		result.h1 = {}
            -- result.collider = {
            --     type = 'NONE'
            -- }
            -- result.autoRemovable = true
            -- result.skipCollision = true
            -- result.skipCollisionCheck = true
            --		result.stations = {}
            --		result.terminalGroups = {}
            --		result.terrainAlignmentLists = {}
            -- result.terrainAlignmentLists = {
            --     {
            --         type = 'EQUAL',
            --         faces = {}
            --     }
            -- }
            -- result.models = {
            --     {
            --         --id = "asset/icon/marker_exclamation.mdl",
            --         --id = "asset/icon/mark.mdl",
            --         --id = "station/street/mark.mdl",
            --         id = 'lollo_assets/mark.mdl',
            --         collider = {
            --             type = 'NONE'
            --         },
            --         autoRemovable = true,
            --         skipCollision = true,
            --         skipCollisionCheck = true,
            --         transf = transf.transl(vec3.new(0.0, 0.0, .0))
            --     }
            -- }

            result.edgeLists = {
                {
                    type = 'STREET',
                    params = {
                        -- collider = {
                        --     type = 'NONE'
                        -- },
                        -- autoRemovable = true,
                        -- skipCollision = true,
                        -- skipCollisionCheck = true,
                        type = 'lollo_medium_1_way_1_lane_street.lua' -- from res/config/street/
                        -- tramTrackType = 'NO'
                    },
                    edges = {
                        -- one entry refers to a position and a tangent
                        {{-4, -4, .0}, {1, .0, .0}}, -- node 0
                        {{4, -4, .0}, {1, .0, .0}} -- node 1
                    },
                    -- edgeType = "BRIDGE",
                    -- edgeTypeName = "cement.lua",
                    freeNodes = {0, 1},
                    --freeNodes = { 1 },
                    -- freeNodes = {},
                    -- collider = {
                    --     type = 'NONE'
                    -- },
                    -- autoRemovable = true,
                    --skipCollision = true, --useless
                    --skipCollisionCheck = true, --useless
                    --					snapNodes = { 0 },  -- node 0 is allowed to snap to other edges of the same type --crashes
                    snapNodes = {0, 1}, -- node 1 is allowed to snap to other edges of the same type
                    snapNodes = {0},
                    snapNodes = {}
                    --					snapNodes = { 0, 1 },  -- node 0 and 1 are allowed to snap to other edges of the same type --crashes
                    --					tag2nodes = {},
                },
                {
                    type = 'STREET',
                    params = {
                        -- collider = {
                        --     type = 'NONE'
                        -- },
                        -- autoRemovable = true,
                        -- skipCollision = true,
                        -- skipCollisionCheck = true,
                        type = 'lollo_medium_1_way_1_lane_street.lua' -- from res/config/street/
                        -- tramTrackType = 'NO'
                    },
                    edges = {
                        -- one entry refers to a position and a tangent
                        {{-4, 4, .0}, {1, .0, .0}}, -- node 0
                        {{4, 4, .0}, {1, .0, .0}} -- node 1
                    },
                    -- edgeType = "BRIDGE",
                    -- edgeTypeName = "cement.lua",
                    freeNodes = {0, 1},
                    --freeNodes = { 1 },
                    --freeNodes = { },
                    -- collider = {
                    --     type = 'NONE'
                    -- },
                    -- autoRemovable = true,
                    --skipCollision = true, --useless
                    --skipCollisionCheck = true, --useless
                    snapNodes = {0, 1}, -- node 1 is allowed to snap to other edges of the same type
                    snapNodes = {0},
                    snapNodes = {}
                    --					tag2nodes = {},
                }
            }

            return result
        end,
        upgradeFn = function(params)
            -- print('LOLLO parallel streets upgradeFn')
            -- dump(true)(params)
        end
    }
end
